package main

import (
	"fmt"
	"sort"
	"strings"
)

type Generator struct {
	spec        *OpenAPISpec
	packageName string
}

func NewGenerator(spec *OpenAPISpec, packageName string) *Generator {
	return &Generator{
		spec:        spec,
		packageName: packageName,
	}
}

func (g *Generator) GenerateTypes() string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// Package %s provides client library for Japan Law API\n", g.packageName))
	sb.WriteString(fmt.Sprintf("// Version: %s\n", g.spec.Info.Version))
	sb.WriteString("// Code generated by clientgen; DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	sb.WriteString("import (\n")
	sb.WriteString("\t\"encoding/json\"\n")
	sb.WriteString("\t\"strings\"\n")
	sb.WriteString("\t\"time\"\n")
	sb.WriteString(")\n\n")

	// Generate common constants
	if len(g.spec.Servers) > 0 {
		sb.WriteString(fmt.Sprintf("// DefaultBaseURL is the default base URL for the API\n"))
		sb.WriteString(fmt.Sprintf("const DefaultBaseURL = %q\n\n", g.spec.Servers[0].URL))
	}

	// Generate structs from schemas
	for _, name := range g.spec.GetSortedSchemas() {
		schema := g.spec.Components.Schemas[name]
		sb.WriteString(g.generateStruct(name, &schema))
		sb.WriteString("\n")
	}

	// Generate additional structs for complex types found in responses
	sb.WriteString(g.generateAdditionalStructs())
	sb.WriteString("\n")

	return sb.String()
}

func (g *Generator) generateAdditionalStructs() string {
	var sb strings.Builder

	// Generate LawItem struct for laws array items
	sb.WriteString("// LawItem represents a single law entry from the laws array\n")
	sb.WriteString("type LawItem struct {\n")
	sb.WriteString("\t// LawInfo represents law information independent of revision history\n")
	sb.WriteString("\tLawInfo *LawInfo `json:\"law_info,omitempty\"`\n")
	sb.WriteString("\t// RevisionInfo represents law information for the retrieved revision history\n")
	sb.WriteString("\tRevisionInfo *RevisionInfo `json:\"revision_info,omitempty\"`\n")
	sb.WriteString("\t// CurrentRevisionInfo represents the latest revision information\n")
	sb.WriteString("\tCurrentRevisionInfo *RevisionInfo `json:\"current_revision_info,omitempty\"`\n")
	sb.WriteString("}\n\n")

	// Generate KeywordItem struct for keyword search results
	sb.WriteString("// KeywordItem represents a single item from keyword search results\n")
	sb.WriteString("type KeywordItem struct {\n")
	sb.WriteString("\t// LawInfo represents law information independent of revision history\n")
	sb.WriteString("\tLawInfo *LawInfo `json:\"law_info,omitempty\"`\n")
	sb.WriteString("\t// RevisionInfo represents law information for the retrieved revision history\n")
	sb.WriteString("\tRevisionInfo *RevisionInfo `json:\"revision_info,omitempty\"`\n")
	sb.WriteString("\t// Sentences represents matching sentences from the search\n")
	sb.WriteString("\tSentences []KeywordSentence `json:\"sentences,omitempty\"`\n")
	sb.WriteString("}\n\n")

	// Generate KeywordSentence struct for sentence matches
	sb.WriteString("// KeywordSentence represents a sentence match from keyword search\n")
	sb.WriteString("type KeywordSentence struct {\n")
	sb.WriteString("\t// Text represents the matching text content\n")
	sb.WriteString("\tText string `json:\"text,omitempty\"`\n")
	sb.WriteString("\t// Position represents the position information\n")
	sb.WriteString("\tPosition string `json:\"position,omitempty\"`\n")
	sb.WriteString("}\n\n")

	// Generate custom date/time types
	sb.WriteString("// Date represents a date in YYYY-MM-DD format\n")
	sb.WriteString("type Date time.Time\n\n")

	sb.WriteString("// UnmarshalJSON implements json.Unmarshaler for Date\n")
	sb.WriteString("func (d *Date) UnmarshalJSON(data []byte) error {\n")
	sb.WriteString("\tif string(data) == \"null\" || string(data) == \"\\\"\\\"\" {\n")
	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tstr := strings.Trim(string(data), \"\\\"\")\n")
	sb.WriteString("\tt, err := time.Parse(\"2006-01-02\", str)\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\t*d = Date(t)\n")
	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// MarshalJSON implements json.Marshaler for Date\n")
	sb.WriteString("func (d Date) MarshalJSON() ([]byte, error) {\n")
	sb.WriteString("\treturn json.Marshal(time.Time(d).Format(\"2006-01-02\"))\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// String returns the string representation of the date\n")
	sb.WriteString("func (d Date) String() string {\n")
	sb.WriteString("\treturn time.Time(d).Format(\"2006-01-02\")\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// DateTime represents a date-time in RFC3339 format\n")
	sb.WriteString("type DateTime time.Time\n\n")

	sb.WriteString("// UnmarshalJSON implements json.Unmarshaler for DateTime\n")
	sb.WriteString("func (dt *DateTime) UnmarshalJSON(data []byte) error {\n")
	sb.WriteString("\tif string(data) == \"null\" || string(data) == \"\\\"\\\"\" {\n")
	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tstr := strings.Trim(string(data), \"\\\"\")\n")
	sb.WriteString("\t// Try RFC3339 format first\n")
	sb.WriteString("\tt, err := time.Parse(time.RFC3339, str)\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\t// Fallback to date-only format\n")
	sb.WriteString("\t\tt, err = time.Parse(\"2006-01-02\", str)\n")
	sb.WriteString("\t\tif err != nil {\n")
	sb.WriteString("\t\t\treturn err\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\t*dt = DateTime(t)\n")
	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// MarshalJSON implements json.Marshaler for DateTime\n")
	sb.WriteString("func (dt DateTime) MarshalJSON() ([]byte, error) {\n")
	sb.WriteString("\treturn json.Marshal(time.Time(dt).Format(time.RFC3339))\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// String returns the string representation of the date-time\n")
	sb.WriteString("func (dt DateTime) String() string {\n")
	sb.WriteString("\treturn time.Time(dt).Format(time.RFC3339)\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *Generator) generateStruct(name string, schema *Schema) string {
	var sb strings.Builder

	structName := toPascalCase(name)

	if schema.Description != "" {
		cleanDesc := cleanDescription(schema.Description)
		if cleanDesc != "" {
			sb.WriteString(fmt.Sprintf("// %s represents %s\n", structName, cleanDesc))
		} else {
			sb.WriteString(fmt.Sprintf("// %s represents a data structure from the API\n", structName))
		}
	}

	if len(schema.Enum) > 0 {
		// Generate enum constants
		sb.WriteString(fmt.Sprintf("type %s string\n\n", structName))
		sb.WriteString(fmt.Sprintf("const (\n"))
		for _, enumValue := range schema.Enum {
			if str, ok := enumValue.(string); ok {
				constName := fmt.Sprintf("%s%s", structName, toPascalCase(str))
				sb.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, structName, str))
			}
		}
		sb.WriteString(")\n")
		return sb.String()
	}

	if schema.Type != "object" || len(schema.Properties) == 0 {
		// Generate basic type definition for non-object types or types without properties
		goType := schema.GoType()
		sb.WriteString(fmt.Sprintf("type %s %s\n", structName, goType))
		return sb.String()
	}

	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Sort properties
	var propNames []string
	for propName := range schema.Properties {
		propNames = append(propNames, propName)
	}
	sort.Strings(propNames)

	for _, propName := range propNames {
		propSchema := schema.Properties[propName]
		fieldName := toPascalCase(propName)
		goType := propSchema.GoType()

		// Special case handling for specific fields
		if structName == "LawsResponse" && propName == "laws" {
			goType = "[]LawItem"
		} else if structName == "KeywordResponse" && propName == "items" {
			goType = "[]KeywordItem"
		} else if structName == "LawRevisionsResponse" && propName == "revisions" {
			goType = "[]RevisionInfo"
		} else {
			// Determine if pointer type should be used
			if !schema.IsRequired(propName) && !isBasicType(goType) {
				goType = "*" + goType
			}
		}

		jsonTag := propName
		if !schema.IsRequired(propName) {
			jsonTag += ",omitempty"
		}

		if propSchema.Description != "" {
			cleanDesc := cleanDescription(propSchema.Description)
			if cleanDesc != "" {
				sb.WriteString(fmt.Sprintf("\t// %s represents %s\n", fieldName, cleanDesc))
			}
		}

		sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag))
	}

	sb.WriteString("}\n")

	return sb.String()
}

func (g *Generator) GenerateClient() string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	sb.WriteString("import (\n")
	sb.WriteString("\t\"encoding/json\"\n")
	sb.WriteString("\t\"fmt\"\n")
	sb.WriteString("\t\"io\"\n")
	sb.WriteString("\t\"net/http\"\n")
	sb.WriteString("\t\"net/url\"\n")
	sb.WriteString("\t\"time\"\n")
	sb.WriteString(")\n\n")

	sb.WriteString("// Client provides access to the Japan Law API\n")
	sb.WriteString("type Client struct {\n")
	sb.WriteString("\tbaseURL    string\n")
	sb.WriteString("\thttpClient *http.Client\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// NewClient creates a new API client\n")
	sb.WriteString("func NewClient() *Client {\n")
	sb.WriteString("\treturn &Client{\n")
	sb.WriteString("\t\tbaseURL:    DefaultBaseURL,\n")
	sb.WriteString("\t\thttpClient: &http.Client{Timeout: 30 * time.Second},\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// SetHTTPClient sets a custom HTTP client\n")
	sb.WriteString("func (c *Client) SetHTTPClient(client *http.Client) {\n")
	sb.WriteString("\tc.httpClient = client\n")
	sb.WriteString("}\n\n")

	// Generate methods for each API endpoint
	for _, path := range g.spec.GetSortedPaths() {
		pathItem := g.spec.Paths[path]
		sb.WriteString(g.generateMethodsForPath(path, &pathItem))
	}

	// Generate helper methods
	sb.WriteString(g.generateHelperMethods())

	return sb.String()
}

func (g *Generator) generateMethodsForPath(path string, pathItem *PathItem) string {
	var sb strings.Builder

	operations := map[string]*Operation{
		"GET":    pathItem.Get,
		"POST":   pathItem.Post,
		"PUT":    pathItem.Put,
		"DELETE": pathItem.Delete,
	}

	for method, operation := range operations {
		if operation != nil {
			sb.WriteString(g.generateMethod(path, method, operation))
		}
	}

	return sb.String()
}

func (g *Generator) generateMethod(path, httpMethod string, operation *Operation) string {
	var sb strings.Builder

	methodName := operation.GetMethodName()

	// Generate parameter type definitions
	var params []string
	var queryParams []Parameter
	var pathParams []Parameter

	for _, param := range operation.Parameters {
		switch param.In {
		case "query":
			queryParams = append(queryParams, param)
		case "path":
			pathParams = append(pathParams, param)
		}
	}

	// Build method signature
	if len(queryParams) > 0 {
		params = append(params, fmt.Sprintf("params *%sParams", methodName))
	}

	// Determine response type
	responseType := "interface{}"
	if successResp := operation.GetSuccessResponse(); successResp != nil {
		for _, mediaType := range successResp.Content {
			if mediaType.Schema != nil {
				responseType = mediaType.Schema.GoType()
				break
			}
		}
	}

	// Generate parameter struct (if query parameters exist)
	if len(queryParams) > 0 {
		sb.WriteString(g.generateParamsStruct(methodName, queryParams))
		sb.WriteString("\n")
	}

	// Method comment
	if operation.Summary != "" {
		cleanSummary := cleanDescription(operation.Summary)
		if cleanSummary != "" {
			sb.WriteString(fmt.Sprintf("// %s %s\n", methodName, cleanSummary))
		} else {
			sb.WriteString(fmt.Sprintf("// %s executes an API request\n", methodName))
		}
	}

	// Method definition
	sb.WriteString(fmt.Sprintf("func (c *Client) %s(", methodName))
	if len(params) > 0 {
		sb.WriteString(strings.Join(params, ", "))
	}
	sb.WriteString(fmt.Sprintf(") (*%s, error) {\n", responseType))

	// Build URL
	sb.WriteString(fmt.Sprintf("\turlPath := c.baseURL + %q\n", path))

	// Replace path parameters
	for _, param := range pathParams {
		sb.WriteString(fmt.Sprintf("\t// TODO: Replace path parameter {%s}\n", param.Name))
		sb.WriteString(fmt.Sprintf("\t// urlPath = strings.ReplaceAll(urlPath, \"{%s}\", pathParamValue)\n", param.Name))
	}

	// Add query parameters
	if len(queryParams) > 0 {
		sb.WriteString("\tif params != nil {\n")
		sb.WriteString("\t\tqueryParams := url.Values{}\n")
		for _, param := range queryParams {
			fieldName := toPascalCase(param.Name)
			if param.Required {
				// Required parameters access directly
				if param.Schema.Type == "array" {
					sb.WriteString(fmt.Sprintf("\t\tif params.%s != nil {\n", fieldName))
					sb.WriteString(fmt.Sprintf("\t\t\tfor _, v := range *params.%s {\n", fieldName))
					sb.WriteString(fmt.Sprintf("\t\t\t\tqueryParams.Add(%q, fmt.Sprintf(\"%%v\", v))\n", param.Name))
					sb.WriteString("\t\t\t}\n")
					sb.WriteString("\t\t}\n")
				} else {
					sb.WriteString(fmt.Sprintf("\t\tqueryParams.Set(%q, fmt.Sprintf(\"%%v\", params.%s))\n", param.Name, fieldName))
				}
			} else {
				// Optional parameters need nil check
				sb.WriteString(fmt.Sprintf("\t\tif params.%s != nil {\n", fieldName))
				if param.Schema.Type == "array" {
					sb.WriteString(fmt.Sprintf("\t\t\tfor _, v := range *params.%s {\n", fieldName))
					sb.WriteString(fmt.Sprintf("\t\t\t\tqueryParams.Add(%q, fmt.Sprintf(\"%%v\", v))\n", param.Name))
					sb.WriteString("\t\t\t}\n")
				} else {
					sb.WriteString(fmt.Sprintf("\t\t\tqueryParams.Set(%q, fmt.Sprintf(\"%%v\", *params.%s))\n", param.Name, fieldName))
				}
				sb.WriteString("\t\t}\n")
			}
		}
		sb.WriteString("\t\tif len(queryParams) > 0 {\n")
		sb.WriteString("\t\t\turlPath += \"?\" + queryParams.Encode()\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t}\n")
	}

	// Create and execute HTTP request
	sb.WriteString(fmt.Sprintf("\treq, err := http.NewRequest(%q, urlPath, nil)\n", httpMethod))
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\tresp, err := c.httpClient.Do(req)\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tdefer resp.Body.Close()\n\n")

	sb.WriteString("\tif resp.StatusCode >= 400 {\n")
	sb.WriteString("\t\tbody, _ := io.ReadAll(resp.Body)\n")
	sb.WriteString("\t\treturn nil, fmt.Errorf(\"API error %d: %s\", resp.StatusCode, string(body))\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString(fmt.Sprintf("\tvar result %s\n", responseType))
	sb.WriteString("\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n")
	sb.WriteString("\t\treturn nil, fmt.Errorf(\"failed to decode response: %w\", err)\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\treturn &result, nil\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *Generator) generateParamsStruct(methodName string, queryParams []Parameter) string {
	var sb strings.Builder

	structName := fmt.Sprintf("%sParams", methodName)
	sb.WriteString(fmt.Sprintf("// %s contains query parameters for %s\n", structName, methodName))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, param := range queryParams {
		fieldName := toPascalCase(param.Name)
		goType := param.Schema.GoType()

		// Optional parameters use pointer types
		if !param.Required {
			goType = "*" + goType
		}

		if param.Description != "" {
			cleanDesc := cleanDescription(param.Description)
			if cleanDesc != "" {
				sb.WriteString(fmt.Sprintf("\t// %s represents %s\n", fieldName, cleanDesc))
			}
		}

		sb.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
	}

	sb.WriteString("}\n")

	return sb.String()
}

func (g *Generator) generateHelperMethods() string {
	var sb strings.Builder

	sb.WriteString("// Helper functions for creating pointer values\n\n")

	// Generate pointer helpers for commonly used types
	basicTypes := []string{"string", "int", "int32", "int64", "bool", "float32", "float64"}
	for _, t := range basicTypes {
		funcName := fmt.Sprintf("%sPtr", strings.Title(t))
		sb.WriteString(fmt.Sprintf("// %s returns a pointer to the %s value\n", funcName, t))
		sb.WriteString(fmt.Sprintf("func %s(v %s) *%s {\n", funcName, t, t))
		sb.WriteString("\treturn &v\n")
		sb.WriteString("}\n\n")
	}

	return sb.String()
}

func isBasicType(goType string) bool {
	basicTypes := map[string]bool{
		"string":    true,
		"int":       true,
		"int32":     true,
		"int64":     true,
		"float32":   true,
		"float64":   true,
		"bool":      true,
		"time.Time": true,
		"Date":      true,
		"DateTime":  true,
	}
	return basicTypes[goType]
}

func cleanDescription(desc string) string {
	// Remove HTML tags and markup
	cleaned := strings.ReplaceAll(desc, "<br>", " ")
	cleaned = strings.ReplaceAll(cleaned, "<br/>", " ")
	cleaned = strings.ReplaceAll(cleaned, "<table", "")
	cleaned = strings.ReplaceAll(cleaned, "</table>", "")
	cleaned = strings.ReplaceAll(cleaned, "<tr", "")
	cleaned = strings.ReplaceAll(cleaned, "</tr>", "")
	cleaned = strings.ReplaceAll(cleaned, "<td", "")
	cleaned = strings.ReplaceAll(cleaned, "</td>", "")
	cleaned = strings.ReplaceAll(cleaned, "<th", "")
	cleaned = strings.ReplaceAll(cleaned, "</th>", "")

	// Remove HTML attributes and tags completely
	cleaned = strings.ReplaceAll(cleaned, "<font color=\"red\">", "")
	cleaned = strings.ReplaceAll(cleaned, "</font>", "")
	cleaned = strings.ReplaceAll(cleaned, "<a href=", "")
	cleaned = strings.ReplaceAll(cleaned, "</a>", "")

	// Remove extra whitespace characters
	cleaned = strings.TrimSpace(cleaned)
	cleaned = strings.ReplaceAll(cleaned, "\n", " ")
	cleaned = strings.ReplaceAll(cleaned, "\t", " ")

	// Collapse multiple spaces into single space
	for strings.Contains(cleaned, "  ") {
		cleaned = strings.ReplaceAll(cleaned, "  ", " ")
	}

	// Decode HTML entities
	cleaned = strings.ReplaceAll(cleaned, "&nbsp;", " ")
	cleaned = strings.ReplaceAll(cleaned, "&amp;", "&")
	cleaned = strings.ReplaceAll(cleaned, "&lt;", "<")
	cleaned = strings.ReplaceAll(cleaned, "&gt;", ">")

	// If the description contains mostly Japanese characters or is too complex,
	// return a generic English description
	if len(cleaned) > 200 || containsComplexJapanese(cleaned) {
		return "field from the API response"
	}

	// Basic Japanese to English translations for common API terms
	replacements := map[string]string{
		"法令ID": "law ID",
		"法令番号": "law number",
		"法令名":  "law title",
		"公布日":  "promulgation date",
		"施行日":  "enforcement date",
		"改正":   "amendment",
		"廃止":   "repeal",
		"取得":   "retrieve",
		"検索":   "search",
		"一覧":   "list",
		"情報":   "information",
		"データ":  "data",
		"ファイル": "file",
		"形式":   "format",
		"種別":   "type",
		"状態":   "status",
		"履歴":   "history",
		"本文":   "text content",
		"添付":   "attachment",
	}

	for japanese, english := range replacements {
		cleaned = strings.ReplaceAll(cleaned, japanese, english)
	}

	cleaned = strings.TrimSpace(cleaned)
	if cleaned == "" {
		return "field from the API response"
	}

	return cleaned
}

func containsComplexJapanese(s string) bool {
	// Count Japanese characters (Hiragana, Katakana, Kanji ranges)
	japaneseCount := 0
	totalCount := 0

	for _, r := range s {
		totalCount++
		if (r >= 0x3040 && r <= 0x309F) || // Hiragana
			(r >= 0x30A0 && r <= 0x30FF) || // Katakana
			(r >= 0x4E00 && r <= 0x9FAF) { // Kanji
			japaneseCount++
		}
	}

	// If more than 60% of characters are Japanese, consider it complex
	if totalCount > 0 && float64(japaneseCount)/float64(totalCount) > 0.6 {
		return true
	}

	return false
}
